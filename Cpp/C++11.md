### C++ 11提出了什么新特性
？？

#### GPT

C++11是C++语言的一个重大标准更新，引入了许多新的语言特性和库，以提高代码的可读性、可维护性和性能。以下是C++11引入的一些主要特性：

1. **自动类型推导（auto关键字）：** 允许编译器推导变量的类型，减少代码中的冗余，提高代码的可读性。

    ```cpp
    auto x = 5;  // x的类型被推导为int
    ```

2. **范围-based for 循环：** 更简洁的语法用于遍历容器中的元素。

    ```cpp
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    for (int number : numbers) {
        // 处理每个元素
    }
    ```

3. **移动语义（移动构造函数和移动赋值操作符）：** 允许在转移资源（例如，动态分配的内存）的所有权时避免不必要的复制，提高性能。

    ```cpp
    std::vector<int> source = getVector();
    std::vector<int> destination = std::move(source);  // 使用移动构造函数
    ```

4. **智能指针（std::unique_ptr和std::shared_ptr）：** 提供更安全、易用的内存管理方式，避免了手动释放内存的繁琐工作。

    ```cpp
    std::unique_ptr<int> uniquePtr = std::make_unique<int>(42);
    std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
    ```

5. **Lambda表达式：** 提供了一种轻量级的、匿名的函数定义方式。

    ```cpp
    auto add = [](int x, int y) { return x + y; };
    ```

6. **新的字符串字面值（Raw String Literals和Unicode 字符串字面值）：** 更灵活的字符串表示方式。

    ```cpp
    const char* rawString = R"(This is a raw string)";
    const char* unicodeString = u8"This is a Unicode string";
    ```

7. **nullptr关键字：** 用于明确表示空指针，取代了传统的`NULL`或`0`。

    ```cpp
    int* ptr = nullptr;
    ```

8. **委托构造函数：** 允许一个构造函数调用同一类中的另一个构造函数。

    ```cpp
    class MyClass {
    public:
        MyClass() : MyClass(0) {}
        MyClass(int x) : value(x) {}
    private:
        int value;
    };
    ```

9. **新的容器和算法：** 引入了新的容器类型如`std::array`和`std::forward_list`，以及一些新的算法。

    ```cpp
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::sort(arr.begin(), arr.end());
    ```
9. **右值引用：** 
右值引用是C++11引入的一项特性，通过它可以支持移动语义和完美转发。右值引用使用双引号（&&）表示，与传统的左值引用（使用单引号&表示）相对应。右值引用允许我们对右值进行引用，其中右值通常是临时对象、字面量、或者表达式的结果。


以上只是C++11引入的一些主要特性。C++标准的更新通常包含许多其他改进和调整。你可以在C++标准的正式文档中找到详细的信息。C++标准文档通常由ISO（国际标准化组织）发布。最新的C++标准文档可以在ISO的网站上购买，也可以在一些在线资源中找到，例如cppreference（https://en.cppreference.com/）这样的网站。cppreference网站提供了详细的C++标准库和语言特性的文档，是一个非常有用的参考资料。

## Lambda表达式的捕获有哪些种类

在C++中，Lambda表达式是一种方便的方式来定义匿名函数。Lambda 表达式可以捕获外部变量，以便在 Lambda 函数体内使用。捕获可以按值或按引用进行，并且可以包含隐式捕获和显式捕获。

以下是 Lambda 表达式的捕获方式：

1. **按值捕获（`[ ]`）：**
   
    ```cpp
    int x = 42;

    auto lambdaByValue = [x]() {
        // Lambda 函数体可以访问 x 的拷贝
        std::cout << x << std::endl;
    };
    ```

    在这个例子中，`[x]` 表示按值捕获 `x`。Lambda 函数体内的 `x` 将是 `x` 的拷贝，而不是原始变量 `x`。

2. **按引用捕获（`[&]`）：**
   
    ```cpp
    int y = 24;

    auto lambdaByReference = [&y]() {
        // Lambda 函数体可以访问 y 的引用
        std::cout << y << std::endl;
    };
    ```

    在这个例子中，`[&y]` 表示按引用捕获 `y`。Lambda 函数体内的 `y` 将引用原始变量 `y`。

3. **混合捕获（`[&, x]` 或 `[=, &y]`）：**

    - `[&, x]` 表示按引用捕获除 `x` 以外的所有外部变量。
    - `[=, &y]` 表示按值捕获除 `y` 以外的所有外部变量。

    ```cpp
    int a = 10;
    int b = 20;

    auto mixedCapture = [&, b]() {
        // Lambda 函数体可以访问 a 的引用，b 的拷贝
        std::cout << a << ", " << b << std::endl;
    };
    ```

4. **隐式捕获：**

    如果使用 `[ ]`，而不指定捕获列表，Lambda 表达式将隐式捕获所使用的外部变量。隐式捕获默认按值进行。

    ```cpp
    int z = 30;

    auto implicitCapture = [&]() {
        // Lambda 函数体可以访问 z 的引用
        std::cout << z << std::endl;
    };
    ```

总体而言，Lambda 表达式的捕获方式提供了很大的灵活性，允许程序员按照需要在 Lambda 函数体中使用外部变量。选择何种捕获方式取决于具体的应用场景和需求。

## C++中Unordered_map与map有哪些区别

`std::map` 和 `std::unordered_map` 是 C++ 中两种不同的关联容器，它们的主要区别在于底层实现和性能特征。

### `std::map`:

- **底层实现：** `std::map` 使用红黑树（Red-Black Tree）实现，这是一种自平衡的二叉搜索树。这意味着 `std::map` 中的元素是按照键的顺序排序的。
  
- **搜索复杂度：** 在 `std::map` 中查找元素的复杂度是 O(log n)，其中 n 是容器中的元素数量。

- **元素顺序：** `std::map` 保持元素的插入顺序。

### `std::unordered_map`:

- **底层实现：** `std::unordered_map` 使用哈希表（Hash Table）实现。哈希表允许通过哈希函数快速查找元素，不保持元素的特定顺序。

- **搜索复杂度：** 在 `std::unordered_map` 中查找元素的复杂度是平均情况下的 O(1)，最坏情况下可能是 O(n)。这是因为哈希冲突可能导致一些额外的操作。

- **元素顺序：** `std::unordered_map` 不保持元素的插入顺序。如果需要有序性，可以使用 `std::map` 或 `std::unordered_map` 的有序版本 `std::map`。

### 选择使用哪个容器：

- 如果你关心元素的顺序，或者需要按照键进行有序访问，使用 `std::map`。
  
- 如果你更关心查找的速度，不需要元素有序，且不会频繁地插入和删除元素，使用 `std::unordered_map`。

- `std::unordered_map` 在插入和查找方面通常比 `std::map` 更快，但它的主要缺点是它不保持元素的有序性。

总的来说，选择使用哪个容器取决于你的具体需求和性能考虑。

## 为什么要将基类析构函数声明为虚函数

难得遇见一个我会一点的，如果基类析构函数不声明为虚函数，那么派生类在析构时候，通过基类指针是无法调用派生类覆盖的析构函数的，这样就会导致派生类的资源无法释放，造成内存泄漏。
### GPT
在C++中，将基类的析构函数声明为虚函数是为了支持多态（Polymorphism）和确保在使用派生类对象时正确释放资源。虚析构函数是实现多态的关键之一。

考虑以下情况：

```cpp
class Base {
public:
    virtual ~Base() {
        // 基类的析构函数声明为虚函数
        // ...
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // 派生类的析构函数
        // ...
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // 使用基类指针释放派生类对象
    return 0;
}
```

如果基类的析构函数不声明为虚函数，当使用基类指针释放派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类特有的资源没有得到释放，造成内存泄漏。

通过将基类析构函数声明为虚函数，可以在运行时动态地选择调用派生类的析构函数，确保释放所有相关资源。这样，即使使用基类指针删除派生类对象，也会调用正确的析构函数。

总之，将基类析构函数声明为虚函数是为了确保在通过基类指针释放派生类对象时能够调用正确的析构函数，从而正确地释放资源，支持多态特性。这是面向对象程序设计中重要的一项实践。

## vector发生扩容时候，会对现有元素进行拷贝吗

当 `std::vector` 进行扩容时，会分配新的内存空间，并将原有元素拷贝到新的内存空间中。这是因为在 C++ 中，动态数组（例如 `std::vector`）通常通过动态分配内存来存储元素，而当容器需要扩容时，需要在新的内存空间中重新构造元素。

扩容时可能发生以下步骤：

1. **分配新的内存空间：** 当 `std::vector` 的容量不足以容纳新元素时，它会分配一个更大的内存块。

2. **将现有元素拷贝到新的内存空间：** 为了保留现有元素，`std::vector` 将现有元素逐个拷贝到新分配的内存中。这可能涉及到复制构造函数或移动构造函数的调用，具体取决于元素类型。

3. **释放旧的内存空间：** 一旦所有元素都被成功拷贝到新的内存空间中，`std::vector` 将释放旧的内存空间。

这个过程确保了容器在扩容后仍然包含原有的元素，并且在内存管理上更为高效。由于拷贝操作的存在，扩容可能导致时间复杂度为 O(n)，其中 n 是元素数量。为了减少扩容的频率，`std::vector` 在扩容时通常会分配一些额外的空间，这个额外空间的大小可能是当前容器大小的一倍或其他策略决定的。

## C++ virtual关键字的作用

我对子类的virtual关键字是这么理解的，如果抽象基类base有一个虚函数virtual function，如果子类A实现function的时候不带virtual关键字，那这个函数就不能够由A的子类B继续实现，是这么理解吗



## 纯虚函数的子类必须给这个纯虚函数进行实现吗

是的，在C++中，如果一个类包含纯虚函数，那么它被称为抽象类，而任何从这个抽象类派生的子类都必须对所有的纯虚函数提供具体的实现，除非这个子类也是一个抽象类。

纯虚函数在基类中是这样定义的：

```cpp
virtual ReturnType FunctionName(Parameters...) = 0;
```

这个`= 0`表示该函数是纯虚函数，也就意味着该函数在基类中没有具体的实现，而是期望派生类提供实现。这是一种常用的设计手段，用于定义接口和实现多态。

因此，当你有一个从这样一个包含纯虚函数的基类派生出的子类时，你必须在子类中为每个纯虚函数提供具体的实现。这样做的目的是确保该子类可以实例化，同时也保证了多态性的实现。如果子类没有实现基类的纯虚函数，那么这个子类也将成为抽象类，不能被实例化。

示例：

```cpp
class Base {
public:
    virtual void pureVirtualFunction() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void pureVirtualFunction() override {
        // 必须实现这个函数
    }
};
```

在这个例子中，`Derived`类必须实现`pureVirtualFunction`函数，否则它也将成为抽象类。

## 什么是抽象类，如果我的子类实现了父类的一个纯虚函数，但这个子类添加了新的纯虚函数，那这个子类还是抽象类吗

抽象类是一种在C++中用来定义接口和实现多态的特殊类。一个类如果包含至少一个纯虚函数，那么它就是抽象类。纯虚函数在类中的声明通常是这样的：

```cpp
virtual ReturnType FunctionName(Parameters...) = 0;
```

这里的`= 0`表示该函数没有具体实现，是一个纯虚函数。纯虚函数的存在要求任何从这个抽象类派生出的具体类必须为这些纯虚函数提供实现，除非派生类自身也是一个抽象类。

现在，针对你的问题：

1. **子类实现了父类的纯虚函数**: 如果一个子类实现了其父类的所有纯虚函数，那么这个子类可以被实例化，它不再是抽象类。

2. **子类添加新的纯虚函数**: 如果这个子类在实现了父类的所有纯虚函数的基础上，又引入了新的自己的纯虚函数，那么这个子类仍然是一个抽象类。因为纯虚函数的存在意味着这个类不能直接实例化，必须由进一步的子类来实现这些新增的纯虚函数。

因此，即使一个子类实现了父类的纯虚函数，但只要它自己又定义了新的纯虚函数，它还是抽象类，不能被实例化。

示例：

```cpp
class Base {
public:
    virtual void pureVirtualFunction() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void pureVirtualFunction() override {
        // 实现了基类的纯虚函数
    }

    virtual void anotherPureVirtualFunction() = 0; // 新的纯虚函数
};

// 'Derived' 仍然是一个抽象类
```

在这个例子中，尽管`Derived`类实现了`Base`类中的`pureVirtualFunction`纯虚函数，但由于它自己引入了一个新的纯虚函数`anotherPureVirtualFunction`，`Derived`仍然是一个抽象类。